#FAFunc

  #start of change history (finally):
  #10.3.2020: add new functions:FAFunc.Compare2Tickers,FAFunc.UnifyTickers


#####ipak function: install and load multiple R packages.####
# check to see if packages are installed. Install them if they are not, then load them into the R session.
# alternatively require() function can be used
ipak <- function(pkg) {
   new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
   if (length(new.pkg))
      install.packages(new.pkg, dependencies = TRUE)
   
   
   sapply(pkg, require, character.only = TRUE) #require() is equivalent to library()
}

# usage and load packages... todo: only load those which are really needed
#packages <-
#  "RODBC" #c("gridExtra", "nloptr", "dplyr", "reshape", "xlsx") #"ggplot2","xlsx", "reshape2",  "microbenchmark","nlshrink","RODBC"
#ipak(packages)
#options(java.parameters = "-Xmx1024m")

####TRANSFORM FACTORS INTO NUMERICS####
as.numeric.factor <- function(x) {
   #check if is already numeric then do nothing
   if (class(x) == "numeric") {
      return(x)
   }
   else
   {
      as.numeric(levels(x))[x]
   }
   
}

####Connect to db ######
FAFunc.GetDB <- function(database = "Aktienmodell") {
  
  ipak("RODBC")

  odbcDriverConnect(
      connection = paste(
         "Driver={SQL Server};server=sqltara;database=",
         database,
         ";trusted_connection=yes;",
         sep = "",
         collapse = ""
      )
   )
}

###check two tickers for equality with sql-function
FAFunc.Compare2Tickers <- function(Ticker1,Ticker2)
{
  con <- FAFunc.GetDB()
  str.query <- paste("Select tickermappings.fCompare2Tickers('",Ticker1,"','",Ticker2,"')",sep="")
  return(as.logical(sqlQuery(con,str.query)))
  
  #example
  #Ticker1 <- 'AMS SE Equity'; Ticker2 <-  'AMS SW Equity'
  #FAFunc.Compare2Tickers(Ticker1,Ticker2)
}

###
FAFunc.UnifyTickers <- function(Ticker2Replace,TickerRef)
{
  #look for every Ticker in Ticker2Replace if there is an equivalent Ticker in Ticker Ref (and replace it with that)
  stopifnot(is.character(Ticker2Replace),is.character(TickerRef))
  
  Ticker2Replace.unq <- unique(Ticker2Replace)
  TickerRef.unq <- unique(TickerRef)
  print(paste("start comparison, will take some time looping through", length(TickerRef.unq),"tickers"))
  for (i in Ticker2Replace.unq)
  {
    cat(".")
    if(any(i==TickerRef.unq)==FALSE)#no need to make sql comparison if tickers are already equal!
    {
    matches <- apply(as.matrix(TickerRef.unq),1,FAFunc.Compare2Tickers,Ticker2=i)
    if(any(matches)){Ticker2Replace[Ticker2Replace==i] <- TickerRef.unq[which(matches)]}  
    }
  }
  return(Ticker2Replace)
  #example
  #Ticker2Replace <- c(rep("AMS SE Equity",2),rep("AMS SW Equity"),rep("SMA SW Equity"))
  #TickerRef <- c(rep("AMS SE Equity",3),"SMAP SW Equity")
  #res <- FAFunc.UnifyTickers(Ticker2Replace,TickerRef)
  
}


####GET BLOOMBERG-TICKERS-Data######
#sfb 2019-03-19: when only one ticker is passed, bb returns a data.frame and not a list. we have to convert it to list
FAFunc.GetFromTickers <-   function(output.as = c("p", "r"),
            Tickers,
            periodicity = "DAILY",
            end_date = Sys.Date(),
            start_date = end_date - 252,
            missing.values = NA,
            printout=FALSE)   {
      ipak(c("Rblpapi"))
      
      if (class(Tickers) != "character") {
         stop("Ticker must be specified as character string")
      }
      opt <- c("periodicitySelection" = periodicity)
      
      print("connecting to bb...")
      blpConnect()
      pd <-
         bdh(Tickers, "px_last", start_date, end_date, options = opt)
      
      print("output from bb...")
      if(printout) print(pd)
      
      #checks
      sec.nr <- length(Tickers)
      
      #when only one ticker is queried, bb returns a data.frame and not a list. we convert it to a list to make use of the subsequent code
      if (class(pd) == "data.frame") {
         pd <- list(pd)
         names(pd) <- Tickers[1]
      }
      
      #check if input ticker count match returned ticker count
      if (sec.nr != length(pd)) {
         stop("not all tickers have been loaded")
      } else      {
         print("ok")
      }
      
      datapoints.nr <- rep(0, sec.nr)
      #print(sec.nr)
      for (i in 1:sec.nr)
      {
         #assign the number of datapoints loaded for each security
         datapoints.nr[i] <- length(pd[[Tickers[i]]][, 2])
      }
      #print(Tickers)
      #print(datapoints.nr)
      if (min(datapoints.nr) != max(datapoints.nr))
      {
         print(
            paste(
               "not all time series are  of the same lengths. missing values are set to ",
               missing.values
            )
         )
      }
      
      d.nr <-
         max(datapoints.nr)  #assign the total datapoints (ie the one for the longest series, should be equal to the one of the 1st series)
      
      if (length(data.frame(pd[Tickers[1]])[, 1]) != d.nr) {
         stop("the first series' dates are used for all others BUT shorter than at least one other")
      }
      
      #create output matrices prices and returns with default values
      prices <-
         data.frame(matrix(rep(missing.values, (d.nr) * sec.nr), d.nr , sec.nr))
      Tickers <- as.character(Tickers)
      colnames(prices) <- Tickers
      rownames(prices) <- data.frame(pd[Tickers[1]])[, 1]
      
      returns <-
         data.frame(matrix(rep(missing.values, (d.nr - 1) * sec.nr), d.nr - 1, sec.nr))
      colnames(returns) <- Tickers
      rownames(returns) <-
         data.frame(pd[Tickers[1]])[2:datapoints.nr[1], 1]
      
      
      print(sec.nr)
      #put prices and calculated returns in the output matrices and set missing values where necessary
      for (i in 1:sec.nr)
      {
         if (d.nr > datapoints.nr[i])
         {
            lacking <- d.nr - datapoints.nr[i]
            prices[(lacking + 1):d.nr, Tickers[i]] <-
               data.frame(pd[Tickers[i]])[, 2]
            returns[(lacking + 1):(d.nr - 1), Tickers[i]] <-
               data.frame(pd[Tickers[i]])[2:(d.nr - lacking), 2] / data.frame(pd[Tickers[i]])[1:(d.nr -
                                                                                                    lacking - 1), 2] - 1
            print(
               paste(
                  Tickers[i],
                  ": replaced ",
                  lacking,
                  "lacking prices with the default value ",
                  missing.values
               )
            )
            
            #check if the dates match with those of the first entry as assumed
            if (all(data.frame(pd[Tickers[1]])[(lacking + 1):(d.nr), 1] !=  data.frame(pd[Tickers[i]])[, 1]))
            {
               print(
                  paste(
                     "dates dont match for security: ",
                     Tickers[i],
                     " consider choosing other tickers or another periodicity. output replaced by NAs to avoid inconsistencies"
                  )
               )
               prices[, Tickers[i]] <- rep(NA, d.nr)
               returns[, Tickers[i]] <- rep(NA, d.nr - 1)
            }
         }
         if (d.nr == datapoints.nr[i])
         {
            prices[, Tickers[i]] <- data.frame(pd[Tickers[i]])[, 2]
            returns[, Tickers[i]] <-
               data.frame(pd[Tickers[i]])[2:d.nr, 2] / data.frame(pd[Tickers[i]])[1:d.nr -
                                                                                     1, 2] - 1
            
            #check if Tickers without prices (probably wrong set)
            if (any(datapoints.nr == 0))
            {
               stop(
                  paste(
                     "The following Tickers dont find ANY prices. Check spelling or delete.:",
                     Tickers[datapoints.nr == 0]
                  )
               )
            }
            
            
            #check if the dates match with those of the first entry as assumed
            if (all(data.frame(pd[Tickers[1]])[, 1] != data.frame(pd[Tickers[i]])[, 1]))
            {
               print(
                  paste(
                     "dates dont match for security: ",
                     Tickers[i],
                     " . consider choosing other tickers or another periodicity. output replaced by NAs to avoid inconsistencies"
                  )
               )
               prices[, Tickers[i]] <- rep(NA, d.nr)
               returns[, Tickers[i]] <- rep(NA, d.nr - 1)
            }
         }
         
      }
      
      
      if (output.as == "p") {
         return(prices)
      }
      if (output.as == "r") {
         return(returns)
      }
      
}

####FindCovarianceMatrix in DB#####
#Find the newest Covariance Matrix in the DB that is calculated with the chosen Returns and by the chosen Calculation Method.
#optional argument: 'NotNeverThan' set to a date value to get the newest CovarianceMatrix before that date

FAFunc.FindNewestCovInDB <-
   function(RelOrAbsReturn,
            Portfolioname,
            NotNeverThan = Sys.Date())
   {
      ipak("RODBC")
      #checks
      if (any(RelOrAbsReturn %in% c("abs", "rel")) == FALSE)
      {
         message(
            paste(
               "The parameter RelOrAbsReturn is set to '",
               RelOrAbsReturn,
               "' only 'rel' or 'abs' are allowed",
               sep = ""
            )
         )
      }
      
      
      #Create query according to specification
      
      #create query depending on Cov-return to use
      if (RelOrAbsReturn == "abs")
      {
         t.query.p1 <- paste(
            "SELECT max (x.RunID) maxRunID ",
            "FROM betsizing.CovarianceMatrixCalculationParams x ",
            "left outer join (select * from betsizing.CovarianceMatrixCalculationParams ",
            "where ParamName='relativeTo') xcm ",
            "on xcm.RunID=x.RunID ",
            "left outer join (select * from betsizing.CovarianceMatrixCalculationParams ",
            "where ParamName='CalcDT') xdate ",
            "on xdate.RunID=x.RunID ",
            "where xcm.ParamName is null ",
            sep = ""
         )
      }
      
      else if (RelOrAbsReturn == "rel")
      {
         t.query.p1 <- paste(
            "SELECT max (x.RunID) maxRunID ",
            "FROM betsizing.CovarianceMatrixCalculationParams x ",
            "left outer join (select * from betsizing.CovarianceMatrixCalculationParams ",
            "where ParamName='relativeTo') xcm ",
            "on xcm.RunID=x.RunID ",
            "left outer join (select * from betsizing.CovarianceMatrixCalculationParams ",
            "where ParamName='CalcDT') xdate ",
            "on xdate.RunID=x.RunID ",
            "where xcm.ParamName is not null ",
            sep = ""
         )
      }
      
      
      #add to query the selected 'date before' and the selected portfolio
      t.query <- paste(
         t.query.p1,
         "AND x.ParamName = 'porName' AND x.ParamValue = '",
         Portfolioname,
         "' ",
         #"AND xdate.ParamValue  <= ", NotNeverThan,###still needs programming, handle the date values!!!!
         sep = ""
      )
      
      #Execute Query and return the COVID
      con <- FAFunc.GetDB()
      maxRunID <- as.numeric(sqlQuery(con, t.query))
      if (is.na(maxRunID)) {
         stop(
            "No Covariance matrix as specified was calculated yet for the given portfolioname and return calc method"
         )
      }
      return(maxRunID)
   }





####Get Covariance Matrix for a set of Repnos#####

#Find the Covariance Matrix for a set of repnos
FAFunc.GetCov4Repnos <- function(Repnos, CovarianceID, CovCalcWay)
{
   
   #checks
   AllowedCovCalcWays <- c("nlshrink", "cov")
   if (any(CovCalcWay %in% AllowedCovCalcWays) == FALSE)
   {
      message(
         paste(
            "The parameter CovCalcWay is set to '",
            CovCalcWay ,
            "' only these values are allowd: ",
            sep = ""
         )
      )
      (AllowedCovCalcWays)
   }
   
   #get Covariance
   #define sql query
   ipak("RODBC")
   t.query <-
      paste(
         "SELECT c.Ticker1, c.Ticker2, c.Covariance, v1.RepNo as 'Repno1',v2.RepNo as 'Repno2'",
         " FROM betsizing.CovarianceMatrixFlattened  c ",
         "inner join Aktienmodell.tickermappings.vRepnosToSCDextended v1 ",
         "on c.Ticker1=v1.BloombergTicker or c.Ticker1=v1.BloombergTicker2 ",
         "inner join Aktienmodell.tickermappings.vRepnosToSCDextended v2 ",
         "on c.Ticker2=v2.BloombergTicker or c.Ticker2=v2.BloombergTicker2 ",
         "where c.RunID= ",
         CovarianceID,
         " and CalculationMethod='",
         CovCalcWay,
         "'",
         sep = ""
      )
   
   
   #get cov from sql
   con <- FAFunc.GetDB()
   cov.t <- sqlQuery(con, t.query)
   
   #convert id_columns from factors to characters
   cov.t$Repno1 <- as.character(cov.t$Repno1)
   cov.t$Repno2 <- as.character(cov.t$Repno2)
   targ$Repno <- as.character(targ$Repno)
   
   
   #ensure all the target Repnos  exist in the covariance matrix
   for (i in 1:sec_nr)
   {
      if (any(cov.t$Repno1 == targ$Repno[i]) == FALSE) {
         stop(
            paste(
               "the Ticker ",
               targ$Ticker[i],
               " is not defined in the corresponding Universe - add to get Covariance",
               sep = ""
            )
         )
      }
   }
   
   
   #form covariance matrix as in tickers (by repno to avoid ticker differences due to different exchange codes)
   
   COV <- matrix(rep(0, sec_nr ^ 2), sec_nr)
   rownames(COV) <- targ$Ticker
   colnames(COV) <- t(targ$Ticker)
   
   for (i in 1:sec_nr)
   {
      for (j in 1:sec_nr)
      {
         if (j >= i)
         {
            #message(paste("i=",i,",j=",j))
            COV[i, j] <-
               cov.t[cov.t$Repno1 %in% targ$Repno[i] &
                        cov.t$Repno2 %in% targ$Repno[j], 3][1]
            COV[j, i] <- COV[i, j]
         }
      }
   }
   
   return(COV)
}


####add n monthes to a date#####
add.month <-
   function(date, n) {
      seq(date, by = paste(n, "months"), length = 2)[2]
   }



####install zip file from any folder########
#installFromZip <- function()
#{install.packages(file.choose(), repos = NULL, type="source")}



####get libraries from central folder /backup of central folder as zip########
#syncLibraries TODO
#FAFunc.ZipLibsBackup <- function(ZipPath="G:/FAP/Equities/Betsizing/Code/RLibs/test",saveLocation="G:/FAP/Equities/Betsizing/Code/RLibsBackups/",filename="RLibs")
# {
#  .libPaths("C:/Rtools/bin")
#  
#   filename <- paste(filename,Sys.Date(),sep="_")
#   zipPath <- zip(files=ZipPath,zipfile=paste(saveLocation,filename,sep=""))
 #}
#FAFunc.ZipLibsBackup(saveLocation="C:/Users/scz/AppData/Local/Temp/",filename="test")

FAFunc.SyncLibraries <- function(syncToPath = .libPaths()[1], syncFromPath= "G:/FAP/Equities/Betsizing/Code/RLibs")
{  
  #Diese Funktion soll anstatt Packages neu zu installieren, alle lokalen Packages löschen 
  #und vom zentralen Directory auf G alle vorhandenen Packages rüberzukopieren
  #die Lokale Instanz greift danach nur auf die lokalen Packages zu (zusätzliche Packages können nac1h belieben dann ebenfalls lokal installiert werden)
  
  #Assertions
  stopifnot(substr(syncToPath,1,3)== "C:/" )
  
  l <- nchar(syncToPath)
  stopifnot(substr(syncToPath,l-5,l) == "/RLibs") 
  
  #Sync Libraries
  print(paste("All packages in:",syncToPath,"are going to be deleted and replaced by the packages in:",syncFromPath))
  
  oldPaths <- .libPaths()
  
  unlink(syncToPath, recursive = TRUE) #would be nicer to just empty the folder
  syncToPath <- substr(syncToPath,1,l-6) #would be nicer to just remove the last folder instead of l-6 (just deleted)
  file.copy(file.path(syncFromPath), to = syncToPath, recursive = TRUE)
  
  .libPaths(oldPaths)
  print("Libraries were sycnronized")
  
}


