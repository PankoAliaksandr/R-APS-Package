# Description
#   This file is a wrapper to call RCO optimizer
#   This script is called from C# using background worker

# Parameters
#   C# calls the script with the next parameters (type is character string):
#   1. Analyst Portfolio Name (Ex. "APSFBEQCHL")
#   2. Caclulation Date (Ex. "2020-02-14")
#   3. Covariance Matrix ID (Ex. "297")
#   4. RCO optimization settings ID (Ex. "37")
#   5. (Still discussed) is Analyst Portfolio real or virtual (Ex. "0" or "1")

# Dependencies (required libraries)
#   1. require("RODBC")
#   2. library(nloptr)
#   3. require("reshape")
#   4. library(dplyr)

# How to test from here
#   0. Check dependencies (libraries)
#   1. After line "call_params = commandArgs(trailingOnly = TRUE)" in the beginning paste:
       # call_params[1] = "APSFBEQCHL"
       # call_params[2] = "2020-03-09"
       # call_params[3] = "297"
       # call_params[4] = "40"
       # call_params[5] = 0
#   2. Run this script

# Algorithm:
  # 1) Based on Portfolio Name and Date prepare a "target table"
  # 2) Based on RCOSetID get RCO_settings
  # 3) Based on CovMaSetID get CovMa (the whole matrix)
  # 4) Execute runRCO() call and get the optimal weights.
  # 5) Save the result in DB


# TODO
#   1) Tradeability issue: for AP doesn't matter for Real matters
#   2) Real Portfolios: not clear if used.
#   3) Create R package and put all functions inside


# Assumptions:
#   1. RCOSetID and CovMaSetID are considered to be correctly filled here.
#      This part is done id C# and account for default setting as well as direct user input
timestamp()
call_params = commandArgs(trailingOnly = TRUE)

print("R script is called sucessfully")
print("Call parameters:")
if(length(call_params) > 0){
  for(i in 1: length(call_params)){
    print(call_params[i])
  }
}else{
  print("No parameters provided. Execution stopped")
  stop("no args provided")
}


# Commented by paa 12.03.20 Reason package test

# # Check and install package if required
# # TODO it's better not to use this, but describe carefully
# # required libraries, since otherwise it can be unclear which
# # location is used during instalation + explicit form is
# # everytime safer
# ipak <- function(pkg) {
#   new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
#   if (length(new.pkg))
#     install.packages(new.pkg, dependencies = TRUE)
#
#
#   sapply(pkg, require, character.only = TRUE) #require() is equivalent to library()
# }
#
# # done
# # Get DB connection
# FAFunc.GetDB <- function(database = "Aktienmodell") {
#   # Description
#   #   This function opens database connection
#
#   # Dependencies:
#   #   1. require("RODBC")
#   ipak("RODBC")
#   if(require("RODBC") == TRUE){
#
#     odbcDriverConnect(
#       connection = paste(
#         "Driver={SQL Server};server=sqltara;database=",
#         database,
#         ";trusted_connection=yes;",
#         sep = "",
#         collapse = ""
#       )
#     )
#   }else{
#     print("library 'RODBC' is not installed")
#     stop("library 'RODBC' is not installed")
#   }
# }
#
#
# # done
# isDate <- function(mydate, format = "%Y-%m-%d") {
#   # Description
#   #   Check is a date in the right format
#
#   # Dependencies
#   #   NO
#
#   tryCatch(
#     {
#       # Try block
#       # Int numbers can be converted to "date" format. Prevent this.
#       mydate <- as.character(mydate)
#
#       if(is.na(as.Date(x = mydate, format = format)) == FALSE){
#         # If date is in wrong format as.Date returns NA
#         # Here it is not NA -> format is correct
#         return(TRUE)
#       }else{
#         # Date format is wrong
#         return(FALSE)
#       }
#     },
#     error = function(err){
#       # This line for example generates an Exception:
#       # as.Date(x = NULL, format = format)
#       return(FALSE)
#     }
#   )
# }
#
# # done
# getRCOSetSettings <- function(RCOSetID, connection){
#
#   # Description
#   #   The function gets all required RCO settings by RCOSetID
#
#   # Dependensies
#   #   library(RODBC)
#
#   if(is.null(RCOSetID) == FALSE &&
#      is.na(RCOSetID) == FALSE){
#
#     query <- paste0("SELECT ",
#                     "[FK_CalculationRCOSettingSetID], ",
#                     "[FK_ParameterName], ",
#                     "[ParameterValue] " ,
#                     "FROM [Aktienmodell].[betsizing].[CalculationRCOSettings] ",
#                     "WHERE [FK_CalculationRCOSettingSetID] = '", RCOSetID, "'")
#
#     result_df <- sqlQuery(channel = connection, query = query, stringsAsFactors = FALSE)
#
#     if(class(result_df) == "data.frame"){
#       if(nrow(result_df) > 0){
#         # Good! There are settings
#         # Optimization requires parameters with values only
#
#         RCO_settings_m <- matrix(data = result_df$ParameterValue,
#                                  nrow = 1,
#                                  ncol = length(result_df$ParameterValue))
#
#         RCO_settings_df <- data.frame(RCO_settings_m)
#
#         colnames(RCO_settings_df) <- result_df$FK_ParameterName
#
#
#         return(RCO_settings_df)
#       }
#       else{
#          print(paste0("Setting set ", RCOSetID, " is empty (no settings)"))
#         stop("Setting set ", RCOSetID, " is empty (no settings)")
#       }
#     }else{
#       # class(result_df) != "data.frame")
#        print("getRCOSetSettiongs: Select statement contains an error ")
#       stop("getRCOSetSettiongs: Select statement contains an error ")
#     }
#
#   }else{
#     # RCOSetID == NULL OR RCOSetID == NA
#      print("RCO Settings ID parameter is not valid")
#     stop("RCO Settings ID parameter is not valid")
#   }
# }
#
# # done
# get_ap_bb_ticker_by_name <- function(portfolioName, connection){
#
#   # Description
#   #   The function derives analyst portfolio bloomberg ticker by name
#
#   # Dependensies
#   #   library(RODBC)
#
#   query <- paste0("SELECT Ticker FROM [Aktienmodell].[config].[CustomPortfolios] ",
#                   "WHERE Name = '", portfolioName, "'")
#
#   result_df <- sqlQuery(channel = connection, query = query)
#
#   # Check the result
#   if(class(result_df) == "data.frame"){
#     # The query executed w/o errors
#     if(nrow(result_df) == 1){
#       # portfolioName has 1:1 relation to bb ap ticker
#       return(as.character(result_df$Ticker[1]))
#     }
#     else{
#        print(paste0("Portfolio", portfolioName, " does not exist (or ambiguous) on ", calculation_date))
#       stop("Portfolio", portfolioName, " does not exist (or ambiguous) on ", calculation_date)
#     }
#   }else{
#     # class(result_df) != "data.frame")
#      print("get_ap_bb_ticker_by_name: Select statement contains an error ")
#     stop("get_ap_bb_ticker_by_name: Select statement contains an error ")
#   }
# }
#
# # done
# getTargetTable <- function(portfolioName, calculation_date, isReal, connection){
#
#   # Description
#   #   The function prepares first set of parameters for RCO:
#   #   Target table includes: Convictions, upper and lower bound, risk buget and tradability
#
#   # Dependensies
#   #   library(RODBC)
#
#   print("in target tab")
#
#   if(is.null(portfolioName) == FALSE &&
#      is.na(portfolioName) == FALSE){
#
#     if(is.null(calculation_date) == FALSE &&
#        is.na(calculation_date) == FALSE){
#
#       if(class(calculation_date) == "Date"){
#
#         const_upper_bound <- 0.1
#         part1 <- 'APKON'
#         # TODO add tradability
#         const_tradeability <- 0.001
#
#         # TODO this part is not required any more since real portfolio are not used
#         if(isReal == TRUE){
#           # the portfolio name corresponds to a real portfolio
#           # In this case consensus analyst portfolio is used
#           # consensus portfolio looks like: 'APKONEQCHSM', when real like: 'EQ_CH_SM'
#
#           part2 <- gsub(pattern = '_', replacement = '', x = portfolioName)
#           portfolioName <- paste0(part1, part2)
#         }
#         else{
#           # the portfolio name corresponds to an analyst portfolio
#           # portfolioName is already correct. Nothing to do.
#         }
#
#         ap_bb_ticker <- get_ap_bb_ticker_by_name(portfolioName = portfolioName,
#                                                  connection = connection)
#
#         query <- paste0("SELECT ",
#                         "AnalystPortfolioConstituent AS Ticker, ",
#                         "BenchmarkConstituentWeightInPercent, ",
#                         "AdjustedConviction ",
#                         "FROM Aktienmodell.betsizing.tvfAnalystPortfolioMembersPerDateWithConvCutOffForOptimization",
#                         "('", ap_bb_ticker, "',",
#                         "'", calculation_date,"',
#                         (SELECT Aktienmodell.betsizing.fGetCutoffTimeBeforeAsOfDate ('",calculation_date ,"'))
#                         )")
#
#         result_df <- sqlQuery(channel = connection, query = query)
#         if(class(result_df) == "data.frame"){
#           if(nrow(result_df) > 0){
#             # Result exists
#             # if a ticker is not in a benchmark set weight = 0
#             result_df[is.na(result_df)] <- 0
#             # Calculate bounds
#             result_df$LowerBound <- (result_df$BenchmarkConstituentWeightInPercent * (-1)) * 0.01
#             result_df$UpperBound <- const_upper_bound
#
#             # Calculate Risk Budget
#             result_df$RiskBudget <- abs(result_df$AdjustedConviction) / sum(abs(result_df$AdjustedConviction), na.rm = TRUE)
#
#             result_df$Tradeability <- const_tradeability
#
#             rownames(result_df) <- result_df$Ticker
#             # Delete 2 columns
#             result_df <- result_df[,!colnames(result_df) %in% c("Ticker", "BenchmarkConstituentWeightInPercent")]
#
#             targ_names <- c("conviction", "lb","ub","RiskBudget", "tradeability")
#             colnames(result_df) <- targ_names
#
#             return(result_df)
#           }
#           else{
#              print(paste0("Portfolio", ap_bb_ticker, " does not exist on ", calculation_date))
#             stop("Portfolio", ap_bb_ticker, " does not exist on ", calculation_date)
#           }
#         }else{
#           # class(result_df) != "data.frame")
#            print("getTargetTable: Select statement contains an error ")
#           stop("getTargetTable: Select statement contains an error ")
#         }
#       }else{
#         # calculation date is not in date format
#          print("Calculation date is  not in 'Date' format")
#         stop("Calculation date is  not in 'Date' format")
#       }
#     }else{
#       # Calculation date is empty
#        print("Calculation date parameter is empty")
#       stop("Calculation date parameter is empty")
#     }
#   }else{
#     # AP_ID == NULL OR AP_ID == NA
#      print("Analyst Portfolio ID parameter is not valid")
#     stop("Analyst Portfolio ID parameter is not valid")
#   }
#    print("getTargetTable finished.")
# }
#
#
# runRCOFromAPS <- function(portfolioName,
#                           calculation_date,
#                           covMaSetID,
#                           RCOSetID,
#                           isReal = FALSE,
#                           calc_method){
#
#
#
#   # Description
#   #   The function executes the opritizer call with
#   #   correct parameters and writes oprimized weights to DB
#
#   # Dependencies:
#   #   1. require("RODBC")
#   #   2. library(nloptr)
#   #   3. require("reshape")
#   #   4. library(dplyr)
#
#   # Functions:
#   #   1. FAFunc.GetDB()     [external*]
#   #   2. getTargetTable     [internal]
#   #   3. getRCOSetSettings  [internal]
#   #   4. f.getCovFromSQL    [external]
#   #   5. f.runRCO           [external]
#   #   6. f.writeRCOresToSQL [external]
#
#   print("The process has been started")
#
#   # Download [external] functions
#   source("G:/FAP/Equities/Betsizing/Code/RCO.R")
#   # debug(f.runRCO)
#
#   connection <- FAFunc.GetDB()
#
#   # Get lower and upper bounds # tradability const
#   target_table <- getTargetTable(portfolioName = portfolioName,
#                                  calculation_date = calculation_date,
#                                  isReal = isReal,
#                                  connection = connection)
#
#   if(nrow(target_table) > 0){
#     print("GOOD: target table is NOT empty")
#      print(target_table, row.names=TRUE, digits=5)
#   }else{
#     print("BAD: target table is empty")
#   }
#   #check if boundaries are compatible with the direction convictions: ADDED!
#   stopifnot(any( (target_table$lb>=0 & target_table$conviction<0) | (target_table$ub<=0 & target_table$conviction>0) )  == FALSE )
#
#
#
#
#   RCO_settings_df <- getRCOSetSettings(RCOSetID = RCOSetID,
#                                       connection = connection)
#   if(length(RCO_settings_df) > 0){
#     print("GOOD: RCO settings table is NOT empty")
#      print(RCO_settings_df, row.names=TRUE)
#   }else{
#     print("BAD: RCO settings table is empty")
#   }
#
#   # TODO  use APS package
#   covMa <- f.getCovFromSQL(RunID = covMaSetID,
#                            CalculationMethod = calc_method,
#                            WideOrLong = "wide")
#
#   if(nrow(covMa) > 0){
#     print("GOOD: covMa is NOT empty")
#   }else{
#     print("BAD: covMa is empty")
#   }
#
#   # check dimensions -> delete if not equal to expected value
#
#   # reduce target_table on those with an active conviction
#   opt_weights_relative <- rep(0,length=nrow((target_table)))
#   sec_a <- target_table$conviction != 0
#   target_table_a <- target_table[sec_a,]
#
#   # The function should calculate optimal weights and update optimal weights
#   tryCatch(
#     { # Try section
#
#       # TODO first copy the function here, second use APS package
#       RCOres <- f.runRCO(targ = target_table_a,
#                          set = RCO_settings_df,
#                          cov = covMa)
#     }, error = function(e){
#       print(paste0("runRCO stopped with an error: ", e))
#       stop("runRCO stopped with an error: ", e)
#     }
#   )
#
#   #check if optimization returned a valid result
#   if(as.logical(RCOres$optim_details["validResult"]) == FALSE) {stop("no valid result found in optimization")}
#
#
#
#   # Optimal weights are updated in SQL table
#   opt_weights_relative[sec_a] <- RCOres$rw
#   opt_weights_portfolio <- -target_table$lb + opt_weights_relative
#   calcdatetime <- RCOres$optim_details["Calculated"]
#   names(opt_weights_relative) <- names(opt_weights_portfolio) <- rownames(target_table)
#   opt_weights_riskcont <- get_rcb(opt_weights_relative,RCOres$COV)
#
#
#
#
#   # create upload df
#   covMaSetID <- as.integer(covMaSetID)
#   RCOSetID <- as.integer(RCOSetID)
#
#   print("Try to call f.writeRCOresToSQL from runRCOFromAPS")
#
#   f.writeRCOresToSQL(res_rel = opt_weights_relative*100,#sql-table stores values in Percentage
#                      res_p = opt_weights_portfolio*100, #sql-table stores values in Percentage
#                      res_rc = opt_weights_riskcont,
#                      portfolio = portfolioName,
#                      covID = covMaSetID,
#                      setID = RCOSetID,
#                      calcdatetime = calcdatetime)
#   # Close connection
#   odbcClose(connection)
# }


if(length(call_params) > 0){

  date <- call_params[2]
  if(APS::isDate(date) == TRUE){
    date <- as.Date(date)
  }else{
    print("parameter date is in wrong format")
    stop("parameter date is in wrong format")
  }

  calc_method <- "nlshrink"
  print(paste("For the Covariance Matrix is the CalcMethod '",calc_method,"' used",sep=""))

  # added paa 12.03.20
  library(APS)
  # Run main function with required params
  APS::runRCOFromAPS(portfolioName = call_params[1],
                    calculation_date = date,
                    covMaSetID = call_params[3],
                    RCOSetID = call_params[4],
                    isReal = FALSE,
                    calc_method = calc_method)
}else{
  # length(call_params) <= 0
   print("No arguments provided")
  stop("No arguments provided")
}
timestamp()

