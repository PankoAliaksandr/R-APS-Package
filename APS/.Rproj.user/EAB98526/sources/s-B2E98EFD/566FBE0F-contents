library(shiny)
library(shinydashboard)
library(DT)
# TODO distance does not work correctly with different X variables
as.of <-  "2020-04-08" #
Portfolio <- "RE_EU"
filepath <- paste0("G:/FAP/Equities/Betsizing/R_results/",Portfolio,"/")

# RCOres_l is loaded
load(paste(filepath,as.of," RCOresPAA.R",sep=""))

# For now only these values make sense
available_x_values_v <- c("setID", "TargetTE", "algo", "cov_run_id", "IndexFlex", "CashTolerance",
                          "Ix_eq_Cash" ,"SoftNetInvConstraint", "LeverageTolerance",
                          "NetInvLambda" , "xtol_rel")

available_y_values_v <- c("TotalRBDev", "NetInvestment", "PortfTEDev",
                          "IndexPosition", "PortfBeta")


header <- dashboardHeader(title = "Optimization Analytics")

sidebar <- dashboardSidebar(
  sidebarMenu(
    menuItem("Main Page", tabName = "main", icon = icon("bar-chart-o")),
    menuItem("Documentation", icon = icon("file-alt"),
             href="http://wiki.suvanet.ch/display/fai/Bets-Sizing%3A+Optimierung+und+deren+Beurteilung#Bets-Sizing%3AOptimierungundderenBeurteilung-EvaluationInShiny"),

    menuItem("Data Selection",
             icon=icon("sliders"),

              # Portfolio
              selectInput(inputId = 'portfolio',
                          label = 'Portfolio',
                          choices = c('RE_EU','RE_CH','EQ_CH_L','EQ_CH_SM','EQ_EU_L','EQ_EU_SM')),
              # Date
              dateInput(inputId = 'date',
                        label = 'Calculation Date',
                        value = Sys.Date()),

             # Settings ID
             numericInput(inputId = 'setid',
                          label = 'Settings ID',
                          value = 1,
                          min = 1,
                          max = ncol(RCOres_l$rw_ma)),

             # Main plot: dependent variable
             selectInput(inputId = 'xcol',
                         label = 'X Variable',
                         choices = available_x_values_v,
                         selected =  "SetID"),

             # Main plot: independent variable
             selectInput(inputId = 'ycol',
                         label = 'Y Variable',
                         choices = available_y_values_v,
                         selected = "total_rb_dev"),

             # Main plot: group by  (use the same colour for a group)
             # TODO currectly only group by 1 single variable is supported
             selectizeInput(inputId = 'group_by',
                            label = 'Group by ',
                            choices = available_x_values_v,
                            selected =  "TargetTE",
                            multiple = FALSE),

             # to add some noise
             # TODO currently is not supported
             sliderInput(inputId = "Jitter",
                         label = "Jitter:",
                         min = 0,
                         max = 1.5,
                         value = 0)
             ), # menu item,
    actionButton(inputId = "save",
                 label =  "Save",
                 icon = icon("save"),
                 class = "btn action-button",
                 width = "85%"),

    checkboxInput(inputId = 'AddSet2SQL',
                          label = 'Add Settings to SQL if saved',
                          value = FALSE)
    ) # sidebar menu
  ) # dashboard sidebar

body <- dashboardBody(tabItems(

  # First tab content
  tabItem(tabName = "main",
          h2("Optimization Analytics"),
          fluidRow(

            tabBox(id = "weights",
                   width = 12,
                   tabPanel(title = "Comparison",
                            splitLayout(cellWidths = c("50%", "50%"),
                                        plotOutput('comparison', click = "comparison_plot_click"),
                                        plotOutput('overview'))),
                   tabPanel(title = "Weights", plotOutput("weights")),
                   tabPanel(title = "RC", plotOutput("rc")),
                   tabPanel(title = "Details", dataTableOutput(outputId = "table"))
        )# tabBox
      )# fluidRow
    )# tabItem
  )# TabItems
)# dashboard body

ui <- dashboardPage(header, sidebar, body)

server <- function(input, output, session){

  # Combine the selected variables into a new data frame
  selectedData <- reactive({

    as.of <-  input$date
    portfolio <- input$portfolio

    validate(
      need(file.exists(paste0("G:/FAP/Equities/Betsizing/R_results/",portfolio,"/",as.of," RCOresPAA.R")),
           label = "Correct portfolio name and date")
    )

    validate(
      need(input$group_by != "", "Fill group by field")
    )

    # For a new portfolio download optimization results

    filepath <- paste0("G:/FAP/Equities/Betsizing/R_results/",portfolio,"/")
    EvalRCOres <- load(file = paste(filepath, as.of, " RCOresPAA.R", sep = ""))
    EvalRCOres <- get(EvalRCOres)

    # TODO finish this
    # Covariance matrix IDs
    available_cov_id_v <- dimnames(EvalRCOres$cov_3D_array)$CovsetID
    cov_id_v <- c("used for opt", available_cov_id_v)

    # Update available Setting IDs
    updateNumericInput(session = session,
                       inputId = 'setid',
                       label = 'Settings ID',
                       value = 1,
                       min = 1,
                       max = ncol(EvalRCOres$rw_ma))

    # update choice options: reduce to what has been varied!
    settings_x_df <- EvalRCOres$settings_df[,available_x_values_v]

    # available options list: contains options names with unique choices for each option
    avail_options_l <- apply(settings_x_df,2,unique)
    # There is no sense to let user vary an optiono with only one available choice
    set_with_sev_opt_ind <- which(lengths(avail_options_l) > 1)
    # take the corresponding settings names (with several optiones available)
    set_with_sev_opt_v <- names(avail_options_l[set_with_sev_opt_ind])

    # Update independent variable select options
    updateSelectInput(session = session,
                      inputId = 'xcol',
                      label = 'X Variable',
                      choices = set_with_sev_opt_v,
                      selected = input$xcol)

    # Update Grouped By parameter options
    updateSelectizeInput(session = session,
                         inputId = 'group_by',
                         label = 'Group by ',
                         choices = set_with_sev_opt_v,
                         selected = input$group_by)

    # tickbox
    output$addSet2SQL <- reactive({input$AddSet2SQL})

    # EvalRCOres
    EvalRCOres
  })

  output$comparison <- renderPlot({

    # The output is a plot
    APS::compareRCOruns(setid = input$setid,
                        RCOres_l = selectedData(),
                        yaxis = input$ycol,
                        xaxis = input$xcol,
                        group_by = input$group_by,
                        current_point = input$setid)

  })

  output$overview <- renderPlot({

    APS::plotSingleSetIDfromRCOres(setid = input$setid,
                                   RCOres_l = selectedData(),
                                   plot_type = "overview")
  })

  output$weights <- renderPlot({

    APS::plotSingleSetIDfromRCOres(setid = input$setid,
                                   RCOres_l = selectedData(),
                                   plot_type = "act_rel_weights")


  })

  output$rc <- renderPlot({

    APS::plotSingleSetIDfromRCOres(setid = input$setid,
                                   RCOres_l = selectedData(),
                                   plot_type = "risk_contr")
  })

  output$table <- DT::renderDataTable({

    APS::draw_table(setid = input$setid,
                    RCOres_l = selectedData())


  })


  # Event Click: Show details for a chosen optimization settings point
  observeEvent(eventExpr = input$comparison_plot_click, handlerExpr =
  {
    # Start of event handler
    # update input
    EvalRCOres <- selectedData()

    # Create a full set of possible options (which can be selected)
    opt_set_and_details_df <- cbind(EvalRCOres$details_df, EvalRCOres$settings_df)
    x_y_df <- opt_set_and_details_df[,c(input$xcol,input$ycol), drop = FALSE]

    # Get click coordinates
    click <- input$comparison_plot_click
    click <- c(click$x,click$y)

    opt_set_and_details_df$dist <- APS::mydistfun(lookup_df = x_y_df, point_v = click)
    clickselected_setID <- opt_set_and_details_df[which.min(opt_set_and_details_df$dist),"setID"]


    if(exists("clickselected_setID"))
    {
      updateNumericInput(session = session,
                         inputId = 'setid',
                         label = 'Settings ID',
                         value = clickselected_setID,
                         min = 1,
                         max = ncol(EvalRCOres$rw_ma))
    }
  })

  #output message
  observeEvent(eventExpr = input$save,
    {
      browser()
      EvalRCOres <- selectedData()

      APS::f.writeOptdetails2xlsx(RCOres_l = EvalRCOres,
                                  Portfolio = input$portfolio,
                                  Calcdate = "LIVE",
                                  ShortIndexWithOptimCash = 1,
                                  ZeroNetInvestment = FALSE,
                                  OnlyID = input$setid)

      if(input$AddSet2SQL) {
        # get single settings set
        set_df <- EvalRCOres$settings_df[input$setid, , drop = FALSE]
        inSQLas <- writeRCOsettingsToSQL(set_df)
      }else{
        inSQLas <- "the settings have not been backed up in the DB"
      }

    showModal(modalDialog(
      title = paste("File for setID",input$setid,"has been written as xls-file"),
      strong(paste("Its filename is",input$portfolio,"_LIVE_optdetails.xlsx"),
             br(),
             "It has been written to the location:",
             br(),
             paste0("G:/FAP/Equities/Betsizing/R_results/",input$portfolio),
             "and its Settings are in SQL as: ",
             br(),
             inSQLas,
             br(),
             br(),
             easyClose = TRUE
      )))
  }
  )
}

shinyApp(ui, server)
